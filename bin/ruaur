#!/usr/bin/env ruby

require "hilighter"
require "optparse"
require "ruaur"

class Flags
    # Query
    INFO = 1

    # Remove
    NOSAVE = 2

    # Sync
    CLEAN = 3
    NAMES_ONLY = 4
    NOCONFIRM = 5
    SEARCH = 6
    UPGRADE = 7
end

class Operation
    QUERY = 1
    REMOVE = 2
    SYNC = 3
end

class RuAURExit
    GOOD = 0
    INVALID_OPTION = 1
    INVALID_ARGUMENT = 2
    MISSING_ARGUMENT = 3
    INVALID_OPERATION = 4
    MULTIPLE_OPERATIONS = 5
    EXCEPTION = 6
    AMBIGUOUS_ARGUMENT = 6
end

def parse(args)
    options = Hash.new
    options["flags"] = Array.new
    options["operation"] = nil
    options["verbose"] = false

    parser = OptionParser.new do |opts|
        opts.summary_width = 17

        opts.banner =
            "Usage: #{File.basename($0)} <operation> [OPTIONS] [pkgs]"

        opts.on("", "OPTIONS")

        opts.on("-h", "--help", "Display this help message") do
            puts opts
            exit
        end

        opts.on("--nocolor", "Disable colorized output") do
            Hilighter.disable
        end

        opts.on(
            "-v",
            "--verbose",
            "Show backtrace when error occurs"
        ) do
            options["verbose"] = true
        end

        opts.on("--version", "Show version") do
            __FILE__.match(/ruaur-(\d+\.\d+\.\d+)/) do |m|
                puts m[1]
            end
            exit RuAURExit::GOOD
        end

        opts.on("", "OPERATIONS")

        opts.on("-Q", "--query", "Query the package database") do
            if (options["operation"])
                puts opts
                exit RuAURExit::MULTIPLE_OPERATIONS
            end
            options["operation"] = Operation::QUERY
        end

        opts.on("-R", "--remove", "Remove package(s)") do
            if (options["operation"])
                puts opts
                exit RuAURExit::MULTIPLE_OPERATIONS
            end
            options["operation"] = Operation::REMOVE
        end

        opts.on("-S", "--sync", "Synchronize package(s)") do
            if (options["operation"])
                puts opts
                exit RuAURExit::MULTIPLE_OPERATIONS
            end
            options["operation"] = Operation::SYNC
        end

        opts.on("", "QUERY_OPTIONS")

        opts.on(
            "-i",
            "--info",
            "Display information for given package(s)"
        ) do
            options["flags"].push(Flags::INFO)
        end

        opts.on("", "REMOVE_OPTIONS")

        opts.on("-n", "--nosave", "Completely remove package") do
            options["flags"].push(Flags::NOSAVE)
        end

        opts.on("", "SYNC_OPTIONS")

        opts.on("-c", "--clean", "Remove packages from the cache") do
            options["flags"].push(Flags::CLEAN)
        end

        opts.on(
            "--names-only",
            "Only show package names (useful for tab-completion)",
        ) do
            options["flags"].push(Flags::NAMES_ONLY)
        end

        opts.on(
            "--noconfirm",
            "Bypass any and all \"Are you sure?\" messages"
        ) do
            options["flags"].push(Flags::NOCONFIRM)
        end

        opts.on(
            "-s",
            "--search",
            "Search the sync database and AUR for package(s)"
        ) do
            options["flags"].push(Flags::SEARCH)
        end

        opts.on("-u", "--sysupgrade", "Upgrade all packages") do
            options["flags"].push(Flags::UPGRADE)
        end
    end

    begin
        parser.parse!
    rescue OptionParser::InvalidOption => e
        puts e.message
        puts parser
        exit RuAURExit::INVALID_OPTION
    rescue OptionParser::InvalidArgument => e
        puts e.message
        puts parser
        exit RuAURExit::INVALID_ARGUMENT
    rescue OptionParser::MissingArgument => e
        puts e.message
        puts parser
        exit RuAURExit::MISSING_ARGUMENT
    rescue OptionParser::AmbiguousOption => e
        puts e.message
        puts parser
        exit RuAURExit::AMBIGUOUS_ARGUMENT
    end

    if (!validate(options))
        puts parser
        exit RuAURExit::INVALID_OPERATION
    end

    options["packages"] = args

    return options
end

def validate(options)
    case options["operation"]
    when Operation::QUERY
        flags = options["flags"].select do |flag|
            flag != Flags::INFO
        end
        return false if (!flags.empty?)
    when Operation::REMOVE
        flags = options["flags"].select do |flag|
            flag != Flags::NOSAVE
        end
        return false if (!flags.empty?)
    when Operation::SYNC
        flags = options["flags"].select do |flag|
            (flag != Flags::CLEAN) &&
            (flag != Flags::NAMES_ONLY) &&
            (flag != Flags::NOCONFIRM) &&
            (flag != Flags::SEARCH) &&
            (flag != Flags::UPGRADE)
        end
        return false if (!flags.empty?)

        if (options["flags"].include?(Flags::CLEAN))
            if (
                options["flags"].include?(Flags::NAMES_ONLY) ||
                options["flags"].include?(Flags::SEARCH) ||
                options["flags"].include?(Flags::UPGRADE)
            )
                return false
            end
        elsif (options["flags"].include?(Flags::SEARCH))
            if (
                options["flags"].include?(Flags::CLEAN) || options["flags"].include?(Flags::UPGRADE)
            )
                return false
            end
        elsif (options["flags"].include?(Flags::UPGRADE))
            if (
                options["flags"].include?(Flags::CLEAN) ||
                options["flags"].include?(Flags::NAMES_ONLY) ||
                options["flags"].include?(Flags::SEARCH)
            )
                return false
            end
        end
    else
        return false
    end

    return true
end

# Parse CLI args
options = parse(ARGV)

begin
    ruaur = RuAUR.new(!Hilighter.disable?)

    case options["operation"]
    when Operation::QUERY
        ruaur.query(
            options["packages"],
            options["flags"].include?(Flags::INFO)
        )
    when Operation::REMOVE
        ruaur.remove(
            options["packages"],
            options["flags"].include?(Flags::NOSAVE)
        )
    when Operation::SYNC
        if (options["flags"].include?(Flags::CLEAN))
            ruaur.clean(options["flags"].include?(Flags::NOCONFIRM))
        elsif (options["flags"].include?(Flags::SEARCH))
            puts ruaur.search(
                options["packages"].join(" "),
                options["flags"].include?(Flags::NAMES_ONLY)
            )
        elsif (options["flags"].include?(Flags::UPGRADE))
            ruaur.upgrade(
                options["flags"].include?(Flags::NOCONFIRM)
            )
        else
            ruaur.install(
                options["packages"],
                options["flags"].include?(Flags::NOCONFIRM)
            )
        end
    end
rescue Interrupt
    # ^C
    # Exit gracefully
rescue Errno::EPIPE
    # Do nothing. This can happen if piping to another program such as
    # less. Usually if less is closed before we're done with STDOUT.
rescue RuAUR::Error => e
    puts e.message
    exit RuAURExit::EXCEPTION
rescue Exception => e
    $stderr.puts
    $stderr.puts "Oops! Looks like an error has occured! If the " \
        "error persists, file a bug at:"
    $stderr.puts
    $stderr.puts "    https://gitlab.com/mjwhitta/ruaur/issues"
    $stderr.puts
    $stderr.puts "Maybe the message below will help. If not, you " \
        "can use the --verbose flag to get"
    $stderr.puts "a backtrace."

    $stderr.puts e.message.white.on_red
    if (options["verbose"])
        e.backtrace.each do |line|
            $stderr.puts line.light_yellow
        end
    end
    exit RuAURExit::EXCEPTION
end
exit RuAURExit::GOOD
